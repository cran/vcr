<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Getting started with vcr</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Getting started with vcr</h1>



<p>{vcr} records and replays HTTP requests so you can test your API
package with speed and confidence. It makes your tests independent of
your internet connection. That makes your tests faster and more
reliable, so you write even more, increasing the coverage of your
package. vcr is particularly important if your package is on CRAN,
because CRAN’s stringent requirements for package reproducibility are
hard to satisfy when you’re at the mercy of a server on the internet.
Using vcr ensures your tests return the same results regardless of when
and where they are run, letting you submit to CRAN with confidence.</p>
<p>This vignette will introduce you to the basics of vcr. While vcr
works with {crul}, {httr}, and {httr2}, in this vignette, we’ll focus on
using httr2 to generate HTTP requests. The same principles apply if
you’re working with crul or httr, you’ll just use different code for
making the requests. I’m also going to use {webfakes} to run a local web
version of <a href="https://hb.cran.dev" class="uri">https://hb.cran.dev</a>. This lets us make real HTTP
requests without having to worry about whether or not the internet is
working.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(vcr)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(testthat)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&gt; Attaching package: &#39;testthat&#39;</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co">#&gt; The following object is masked _by_ &#39;.GlobalEnv&#39;:</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">#&gt;     test_that</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="fu">library</span>(httr2, <span class="at">warn.conflicts =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>httpbin <span class="ot">&lt;-</span> webfakes<span class="sc">::</span><span class="fu">local_app_process</span>(webfakes<span class="sc">::</span><span class="fu">httpbin_app</span>())</span></code></pre></div>
<div id="testing-with-vcr" class="section level2">
<h2>Testing with vcr</h2>
<p>The central metaphor of vcr is a video cassette/video tape. This is
what records your HTTP <strong>interactions</strong>, the pairs of HTTP
request and response. You <strong>insert</strong> a cassette to start
the recording or begin the replay, and <strong>eject</strong> it when
you’re done. To use vcr in a test, include a call to
<code>vcr::local_cassette()</code>: it inserts the cassette and
automatically ejects it when the test is done.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">test_that</span>(<span class="st">&quot;my test&quot;</span>, {</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_cassette</span>(<span class="st">&quot;get&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  req <span class="ot">&lt;-</span> <span class="fu">request</span>(httpbin<span class="sc">$</span><span class="fu">url</span>(<span class="st">&quot;/get&quot;</span>))</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  resp <span class="ot">&lt;-</span> <span class="fu">req_perform</span>(req)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  json <span class="ot">&lt;-</span> <span class="fu">resp_body_json</span>(resp)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  <span class="fu">expect_named</span>(json, <span class="fu">c</span>(<span class="st">&quot;args&quot;</span>, <span class="st">&quot;headers&quot;</span>, <span class="st">&quot;origin&quot;</span>, <span class="st">&quot;path&quot;</span>, <span class="st">&quot;url&quot;</span>))</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>})</span></code></pre></div>
<p>The first time this test runs, vcr will record the requests and their
responses in a <strong>cassette</strong>, a YAML file that lives in
<code>test/testthat/_vcr</code>. In subsequent runs, vcr will replay
those cached responses, freeing your test from the vagaries of the
internet, making it both faster and more reliable. You might notice that
this makes vcr a bit like a web cache (in that it replays previously
saved responses) and a bit like <a href="https://testthat.r-lib.org/articles/snapshotting.html">snapshot
testing</a> (in that we’re storing human-readable data in the test
directory).</p>
<p>Get in the habit of running tests twice that use {vcr}, once to
record new cassettes, and a second time immediately after to replay
cassettes to make sure your tests work with recorded cassettes.</p>
<p>Generally, you will want to ensure that every test has a uniquely
named cassette, unless you are deliberately re-using the same
request-response pair to test different parts of your package code. If
you try to use the same cassette for different requests, you’ll discover
that it errors because once a cassette has been recorded, it ensures
that httr2, httr, and crul can only generate responses from the cached
interactions.</p>
<p>You can see exactly what vcr is doing with
<code>local_vcr_configure_log()</code>. This turns logging on so you can
see each step in the recording and replaying process. In this case,
since it’s the second run of the test, you can see that vcr loads the
previously saved interaction then replays it.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">test_that</span>(<span class="st">&quot;my test&quot;</span>, {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_vcr_configure_log</span>(<span class="at">file =</span> <span class="fu">stdout</span>())</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_cassette</span>(<span class="st">&quot;get&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  req <span class="ot">&lt;-</span> <span class="fu">request</span>(httpbin<span class="sc">$</span><span class="fu">url</span>(<span class="st">&quot;/get&quot;</span>))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  resp <span class="ot">&lt;-</span> <span class="fu">req_perform</span>(req)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  json <span class="ot">&lt;-</span> <span class="fu">resp_body_json</span>(resp)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>  <span class="fu">expect_named</span>(json, <span class="fu">c</span>(<span class="st">&quot;args&quot;</span>, <span class="st">&quot;headers&quot;</span>, <span class="st">&quot;origin&quot;</span>, <span class="st">&quot;path&quot;</span>, <span class="st">&quot;url&quot;</span>))</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>})</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; [Cassette: get] Inserting &#39;get.yml&#39; (with 1 interactions)</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; [Cassette: get]   Mode: replaying</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt; [Cassette: get] Handling request: GET http://127.0.0.1:57456/get</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt; [Cassette: get]   Looking for existing requests using method/uri</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt; [Cassette: get]     Request 1: MATCH</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">#&gt; [Cassette: get]   Replaying response 1</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">#&gt; [Cassette: get] Ejecting</span></span></code></pre></div>
<p>You can learn more about logging and how to use it to debug cases
where vcr behaves unexpectedly in
<code>vignette(&quot;debugging&quot;)</code>.</p>
</div>
<div id="cassette-files" class="section level2">
<h2>Cassette files</h2>
<p>It’s good practice to look at the cassette files that are saved to
disk, for instance before committing them to Git or before merging a PR.
This will help you understand how vcr works by seeing exactly what data
it uses. Here’s the cassette we created above:</p>
<pre><code>#&gt; ```yaml</code></pre>
<pre><code>#&gt; http_interactions:
#&gt; - request:
#&gt;     method: GET
#&gt;     uri: http://127.0.0.1:57456/get
#&gt;   response:
#&gt;     status: 200
#&gt;     headers:
#&gt;       Connection: close
#&gt;       Date: Wed, 23 Jul 2025 05:06:29 GMT
#&gt;       Content-Type: application/json
#&gt;       Content-Length: &#39;270&#39;
#&gt;       ETag: &#39;&quot;c9b75aa0&quot;&#39;
#&gt;     body:
#&gt;       string: |-
#&gt;         {
#&gt;           &quot;args&quot;: {},
#&gt;           &quot;headers&quot;: {
#&gt;             &quot;Host&quot;: &quot;127.0.0.1:57456&quot;,
#&gt;             &quot;User-Agent&quot;: &quot;httr2/1.2.0 r-curl/6.4.0 libcurl/8.14.1&quot;,
#&gt;             &quot;Accept&quot;: &quot;*/*&quot;,
#&gt;             &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;
#&gt;           },
#&gt;           &quot;origin&quot;: &quot;127.0.0.1&quot;,
#&gt;           &quot;path&quot;: &quot;/get&quot;,
#&gt;           &quot;url&quot;: &quot;http://127.0.0.1:57456/get&quot;
#&gt;         }
#&gt;   recorded_at: 2025-07-23 05:06:29
#&gt; recorded_with: VCR-vcr/2.0.0</code></pre>
<pre><code>#&gt; 
#&gt; ```</code></pre>
<p>You can see that it records all components of the response, along
with the components of the request used for matching (which defaults to
<code>method</code> and <code>uri</code>; more on that shortly). The
first time you use vcr with your package, it’s a really good idea to
closely look at this file to make sure that you aren’t accidentally
leaking any secrets. Learn the details in
<code>vignette(&quot;secrets&quot;)</code>.</p>
<p>Sometimes it also makes sense to manually edit the cassettes.
Manually editing is typically most useful when you’re testing error
handling code, because it allows you to create responses that would
otherwise be hard to get the API to generate.</p>
</div>
<div id="request-matching" class="section level2">
<h2>Request matching</h2>
<p>By default, vcr looks for matching requests using just the HTTP
method and the URI. If you need to match requests differently you can
use the <code>match_requests_on</code> parameter. The most likely reason
to change this is to also match on the request body. You can do this in
two ways: with <code>&quot;body&quot;</code> or with <code>&quot;body_json&quot;</code>. If
your API uses JSON (like most modern APIs) you should use the
<code>body_json</code> request matcher: that will parse the body as JSON
so you’ll get more informative messages if a new request doesn’t match a
request saved in a cassette.</p>
<p>Here’s a little example with logging turned on, so you can see
exactly what’s happening:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># A pretend function that would normally be found somewhere in `R/`</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>get_data <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">b =</span> <span class="dv">1</span>) {</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  req <span class="ot">&lt;-</span> <span class="fu">request</span>(httpbin<span class="sc">$</span><span class="fu">url</span>(<span class="st">&quot;/post&quot;</span>))</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  req <span class="ot">&lt;-</span> <span class="fu">req_body_json</span>(req, <span class="fu">list</span>(<span class="at">x =</span> <span class="dv">1</span>, <span class="at">y =</span> <span class="fu">list</span>(<span class="at">a =</span> <span class="dv">1</span>, <span class="at">b =</span> b)))</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  resp <span class="ot">&lt;-</span> <span class="fu">req_perform</span>(req)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="fu">resp_body_json</span>(resp)</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>}</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co"># A pretend test that would normally be found in `test/testthat/`.</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="fu">test_that</span>(<span class="st">&quot;my test&quot;</span>, {</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_vcr_configure_log</span>(<span class="at">file =</span> <span class="fu">stdout</span>())</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_cassette</span>(</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    <span class="st">&quot;body&quot;</span>,</span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    <span class="at">match_requests_on =</span> <span class="fu">c</span>(<span class="st">&quot;method&quot;</span>, <span class="st">&quot;uri&quot;</span>, <span class="st">&quot;body_json&quot;</span>)</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>  )</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">get_data</span>(<span class="at">b =</span> <span class="dv">1</span>)</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>  <span class="fu">expect_named</span>(data<span class="sc">$</span>json, <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>})</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Inserting &#39;body.yml&#39; (new cassette)</span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Mode: recording</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Handling request: POST http://127.0.0.1:57456/post</span></span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Recording response: 200 with 509 bytes of application/json data</span></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Ejecting</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">test_that</span>(<span class="st">&quot;my test&quot;</span>, {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_vcr_configure_log</span>(<span class="at">file =</span> <span class="fu">stdout</span>())</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_cassette</span>(</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="st">&quot;body&quot;</span>,</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="at">match_requests_on =</span> <span class="fu">c</span>(<span class="st">&quot;method&quot;</span>, <span class="st">&quot;uri&quot;</span>, <span class="st">&quot;body_json&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  )</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">get_data</span>(<span class="at">b =</span> <span class="dv">2</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>  <span class="fu">expect_named</span>(data<span class="sc">$</span>json, <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>})</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Inserting &#39;body.yml&#39; (with 1 interactions)</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Mode: replaying</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Handling request: POST http://127.0.0.1:57456/post</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Looking for existing requests using method/uri/body_json</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]     Request 1: NO MATCH</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]       `matching$body$y$b`: 2</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]       `recorded$body$y$b`: 1</span></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   No matching requests</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a><span class="co">#&gt; Error:</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a><span class="co">#&gt; ! Failed to find matching request in active cassette, &quot;body&quot;.</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a><span class="co">#&gt; ℹ Learn more in `vignette(vcr::debugging)`.</span></span></code></pre></div>
<p>If you look at the log you’ll note that we see exactly where the
difference is in the json, even though it’s buried several layers deep.
Compare this to just using <code>&quot;body&quot;</code>, where you have to
carefully compare two strings.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">test_that</span>(<span class="st">&quot;my test&quot;</span>, {</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_vcr_configure_log</span>(<span class="at">file =</span> <span class="fu">stdout</span>())</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  vcr<span class="sc">::</span><span class="fu">local_cassette</span>(<span class="st">&quot;body&quot;</span>, <span class="at">match_requests_on =</span> <span class="fu">c</span>(<span class="st">&quot;method&quot;</span>, <span class="st">&quot;uri&quot;</span>, <span class="st">&quot;body&quot;</span>))</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">get_data</span>(<span class="at">b =</span> <span class="dv">2</span>)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="fu">expect_named</span>(data<span class="sc">$</span>json, <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>})</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Inserting &#39;body.yml&#39; (with 1 interactions)</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Mode: replaying</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; [Cassette: body] Handling request: POST http://127.0.0.1:57456/post {&quot;x&quot;:1,&quot;y&quot;:{&quot;a&quot;:1,&quot;b&quot;:2}}</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   Looking for existing requests using method/uri/body</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]     Request 1: NO MATCH</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]       `matching$body`: &quot;{\&quot;x\&quot;:1,\&quot;y\&quot;:{\&quot;a\&quot;:1,\&quot;b\&quot;:2}}&quot;</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]       `recorded$body`: &quot;{\&quot;x\&quot;:1,\&quot;y\&quot;:{\&quot;a\&quot;:1,\&quot;b\&quot;:1}}&quot;</span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="co">#&gt; [Cassette: body]   No matching requests</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a><span class="co">#&gt; Error:</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a><span class="co">#&gt; ! Failed to find matching request in active cassette, &quot;body&quot;.</span></span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a><span class="co">#&gt; ℹ Learn more in `vignette(vcr::debugging)`.</span></span></code></pre></div>
</div>
<div id="what-happens-if-the-api-changes" class="section level2">
<h2>What happens if the API changes?</h2>
<p>vcr isolates your tests from the internet. Most of the time that’s
great because it keeps your tests fast and protects them against any
minor glitches. But what happens if the API fundamentally changes? Your
tests will continue to pass but real code will fail. This shouldn’t
generally be a problem with well designed APIs, because a well designed
API will include an explicit version either in the URL or in a header.
But not every API is well designed, and you probably want some
protection in either case. There are two main options:</p>
<ul>
<li><p>Include a small number of tests that don’t use cassettes, so that
they always use the live API. These tests should be protected by
<code>skip_on_cran()</code> so that they never run on CRAN.</p></li>
<li><p>Set up a GitHub action (or similar) that runs
<code>R CMD check</code> with env var <code>VCR_TURN_OFF=true</code>.
This turns off all vcr usage so that all requests are live. You might
want to set this up to run weekly, so you find out when the API changes
(even when your package doesn’t), but aren’t overwhelmed with
notifications.</p></li>
</ul>
<p>Learn more in <a href="https://books.ropensci.org/http-testing/real-requests-chapter.html" class="uri">https://books.ropensci.org/http-testing/real-requests-chapter.html</a>.</p>
</div>
<div id="other-uses-examples-and-vignettes" class="section level2">
<h2>Other uses: examples and vignettes</h2>
<p>Now that you’re familiar with using vcr for your unit tests, you
might wonder if there are other places you can use it in your packages.
There are! Two other important use cases are in examples and
vignettes:</p>
<ul>
<li><p>Use <code>vcr::setup_knitr()</code> in your vignettes to enable a
special knitr chunk hook that allows you to use vcr cassettes by setting
the <code>cassette</code> chunk option.</p></li>
<li><p>Use <code>vcr::insert_example_cassette()</code> and
<code>vcr::eject_cassette()</code> in examples. You can surround these
commands in <code>\dontshow{}</code> so your users don’t see them, but
they’re still run.</p></li>
</ul>
<p>Just as in testing, for both of these use cases immediately replay
the cassettes after first recording any new ones to make sure the
replayed cassettes work.</p>
<p>If you use {pkgdown} to generate package documentation, using it to
build examples and vignettes is a great way to both create cassettes on
a first run of <code>pkgdown::build_site()</code> and make sure they
work on a second and any subsequent runs.</p>
<p>Read the documentation for these functions to get all the
details.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>vcr offers a powerful solution for testing API-dependent packages,
making your tests faster, more reliable, and CRAN-friendly. By recording
HTTP interactions and replaying them in subsequent test runs, it
isolates your tests from internet connectivity issues and API
fluctuations.</p>
<p>To recap the key points:</p>
<ul>
<li>Use <code>vcr::local_cassette()</code> in your tests to record and
replay HTTP interactions.</li>
<li>Examine cassette files to understand what’s being recorded and to
ensure no secrets are leaked.</li>
<li>Customize request matching with <code>match_requests_on</code> when
needed.</li>
<li>Consider strategies for detecting API changes, like occasional live
tests.</li>
<li>Use <code>vcr::setup_knitr()</code> and
<code>vcr::insert_example_cassette()</code> to also use vcr in examples
and vignettes.</li>
</ul>
<p>For more advanced use cases and troubleshooting, explore the other
vignettes in the package, particularly
<code>vignette(&quot;debugging&quot;)</code> and <code>vignette(&quot;secrets&quot;)</code>.
The <a href="https://books.ropensci.org/http-testing/">HTTP testing
book</a> is also an excellent resource for deepening your understanding
of HTTP testing in R.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
